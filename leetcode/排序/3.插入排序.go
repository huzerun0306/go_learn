package main

import "fmt"

/*
1、从第一个元素开始，该元素可以认为已经被排序；
2、取出下一个元素，在已经排序的元素序列中从后向前扫描；
3、如果该元素（已排序）大于新元素，将该元素移到下一位置；
4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5、将新元素插入到该位置后；
6、重复步骤2~5。
依次选择没有排序的数字去循环根据大小插入到排序了的数组里面，从第二位开始往前面的数组插

时间复杂度 O(n^2)  最好复杂度O(n)   空间复杂度O(1)  稳定性：稳定

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，
就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大
则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把
想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的
顺序，所以插入排序是稳定的。
*/

func crpx(arr []int) []int {
	for i := 1; i < len(arr); i++ {
		currentIndex := i - 1
		currentValue := arr[i]
		for currentIndex >= 0 && arr[currentIndex] > currentValue {
			//这里一直判断前面有和一个数是不是大于后面一个数，如果大于，后面数就等于前面数然后再向前比较，
			//如果小于，就推出循环并把当前那个数弄成最小的
			arr[i] = arr[currentIndex]
			currentIndex--
		}
		arr[currentIndex+1] = currentValue
	}
	return arr
}
func main() {
	a := []int{4, 2, 3, 6, 5}
	fmt.Println(crpx(a))
}
