package main

/*
循环数组arr1把最大值max取出来，然后创建一个长度为max+1的数组arr2，在循环数组把arr1的值取出来放到arr2
arr1的值对应arr2的key，arr2的value为arr1的值的个数，然后循环arr2，把他们一次放入arr1即是排序完成的
优化可以把最小值找出来，arr2的长度就是max-min。比较集中的数字就可以占据更小的空间

arr2的value不要设成个数，而是设成他应该在的索引的最后一位，比如
[90,99,95,94,95] 正常是这样
value	1	0	0	0	1	2	0	0	0	1
index	0	1	2	3	4	5	6	7	8	9

可以变成这样
value	1	1	1	1	2	4	4	4	4	5
index	0	1	2	3	4	5	6	7	8	9
目的是存储当前元素值的最后位置，譬如下标为9的元素，不管有多少个值为99的元素，反正该值的元素最后一个位置
是5.倒序遍历array数组，第一个被遍历的元素Kan的95，找到countArray数组下标为5的value值，是4，代表Kan
是在输出数组sortArray中排的位置是第四位（即，是输出数组sortArray[3]的值，注意，这个下标值可以通过
countArray对应的元素值减1得到，countArray对应的元素值又可以通过countArray[array[i]-min]得到），
然后countArray数组下标为5的value值相应减去1，4—>3，依次遍历，过程中再遇到95，那么该95排的位置是第
三位，如此类推。这样一来，就可以清楚的将同样是95分的Jack和Kan排出顺序来，这就是稳定排序。
*/
